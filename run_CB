function run_CB(source, eventdata)
    
    %Set & retrieve parameters from the GUI
    params = guidata(source);
    trainedleftwink = params.trainedleftwink;
    trainedrightwink = params.trainedrightwink;
    trainedleftjaw = params.trainedleftjaw;
    trainedrightjaw = params.trainedrightjaw;
    trainedbothjaws = params.trainedbothjaws;
    params.run = 1;
    run = 1;
    guidata(source,params);
    
    %Display Formatting
    f_run = figure('Visible','off',...
            'Color',[0 0 1],...
            'NumberTitle','off','Name','Running!',...
            'Position',[200,200,500,300]);
        
    text_run = uicontrol(f_run,'Style','text',...
                'FontSize',[20],...
                'BackgroundColor',[0 0 1],...
                'Visible','off',...
                'Position',[50 100 400 130]);
     
    %Check if atleast one the parameters are trained so atleast one control
    %signal can be utilized
    if(trainedleftwink == 0 && trainedrightwink == 0 && trainedleftjaw == 0 && trainedrightjaw == 0 && trainedbothjaws == 0)
        set(f_run,'Visible','on');
        set(text_run,'Visible','on','String','Please run one of the training programs first');
        pause(2.5);
        set(f_run,'Visible','off');
        return;
    end
    
    %Load training parameters into the workspace
    if(trainedleftwink ==1)
        load('leftwinkparams.mat');
    end
    if(trainedrightwink ==1)
        load('rightwinkparams.mat');
    end
    if(trainedleftjaw ==1)
        load('leftjawparams.mat');
    end
    if(trainedrightjaw ==1)
        load('rightjawparams.mat');
    end
    if(trainedbothjaws ==1)
        load('bothjawparams.mat');
    end
    
    %Constants
    SAMPLINGRATE = 128;
    CHANNELS = 14;
    wink_channel_set = [2,13];
    jaw_channel_set = [1,2,3,4,11,12,13,14];
    counter = 1;
    
    %Hardware Constants
    a = EmotivEEG;
    a.Run;
    while(run)
        %Retrieve most recent sample
        sample(1:128,1:14) = a.data(1:128,4:17);
        
        if(trainedleftwink == 1 || trainedrightwink == 1)
        %Begin Wink Analysis%
            %Calculate Variance, Power, Ratio of Power
            k = 0;
            for i = wink_channel_set;
                %use k instead of loop_set, goes from 1-2
                k = k+1;
                %Calculate the variances in all the wink samples
                wink_var(k) = var(sample(:,i));

                %Fourier Transform of EEG data on specified channel
                w_F(k,:) = fft(sample(:,i), SAMPLINGRATE);
                w_F(k,1) = 0;

                wink_power(k) = 0;

                %Take power of frequencies across 10-20Hz
                for j = 10:20;
                    wink_power(k) = wink_power(k)+ abs(w_F(k,j))^2;
                end

                %Add up the values around the peak, ask Ryan if the 127 should
                %change to 128, doesnt make a difference at all
                wink_peak(k) = 0;
                [Y,ind] = max(sample(:,i));
                for q = 1:10
                    wink_peak(k) = wink_peak(k)+ abs(sample(min(max((ind-3)+q,1),127),i));
                end
            end

            %Calculating ratios of power
            wink_p_ratio(1) = wink_power(1) / wink_power(2);
            wink_p_ratio(2) = wink_power(2) / wink_power(1);
            wink_peak_ratio(1) = wink_peak(2) / wink_peak(1);
            %wink_peak_ratio(counter,2) = wink_peak(counter,1) / wink_peak(counter,2);

            %Calculating ratios of variance
            wink_v_ratio(1) = wink_var(1) / wink_var(2);
            wink_v_ratio(2) = wink_var(2) / wink_var(1);

            %Calculating correlation
            sigma_count = 0;
            for i = wink_channel_set
                for j = wink_channel_set
                    if(i ~= j && j > i)
                        sigma_count = sigma_count+1;
                        C = corrcoef(sample(:,i), sample(:,j));
                        wink_sigma(sigma_count) = C(2,1);
                    end
                end
            end
        %End Wink Analysis
        
        %Begin Wink Prediction%
            data = [wink_v_ratio,wink_p_ratio,wink_peak];
            
            %Used for calculating the length of the row vector in data
            data_size = size(data);
            data_param = data_size(2);
          
            %Simulate for Left Eye
            if(trainedleftwink == 1)
                %Simulate Logistic Regression Prediction
                wink_left_LR = 2-1/(1+exp(-dot(w_B_l,[1 data(1,1:data_param)])));
                %Simulate Artificial Neural Network Prediction
                wink_left_ANN = sim(w_net_l,data(:,1:data_param)'); 
                %Simulate Support Vector Machine Prediction
                wink_left_SVM = svmclassify(w_SVM_l,data(:,1:data_param));
                %Simulate K Nearest Neighbor Prediction
                wink_left_KNN = predict(w_KNN_l,data(:,1:data_param));
                %Simulate Linear Discriminant Analysis Prediction
                wink_left_LDA = predict(w_LDA_l,data(:,1:data_param));
                %Predictions for Training Networks seperated for each Eye 
                w_learning_data_l = [wink_left_ANN' wink_left_LR' wink_left_SVM wink_left_KNN wink_left_LDA];
                wink_left_ensemble = 2-1/(1+exp(-dot(w_B_l_inception,[1 w_learning_data_l(1,:)])));
            end
        
            %Simulate for Right Eye
            if(trainedrightwink == 1)
                %Simulate Logistic Regression Prediction
                wink_right_LR = 2-1/(1+exp(-dot(w_B_r,[1 data(1,1:data_param)])));
                %Simulate Artificial Neural Network Prediction
                wink_right_ANN = sim(w_net_r,data(:,1:data_param)'); 
                %Simulate Support Vector Machine Prediction
                wink_right_SVM = svmclassify(w_SVM_r,data(:,1:data_param));
                %Simulate K Nearest Neighbor Prediction
                wink_right_KNN = predict(w_KNN_r,data(:,1:data_param));
                %Simulate Linear Discriminant Analysis Prediction
                wink_right_LDA = predict(w_LDA_r,data(:,1:data_param));
                %Predictions for Training Networks seperated for each Eye 
                w_learning_data_r = [wink_right_ANN' wink_right_LR' wink_right_SVM wink_right_KNN wink_right_LDA];
                wink_right_ensemble = 2-1/(1+exp(-dot(w_B_l_inception,[1 w_learning_data_r(1,:)])));
            end
            %A counter that keeps track of how many Training Machines out
            %of SVM, KNN, and LDA believe it is correct
            w_council(1) = 0;
            w_council(2) = 0;
                %Left Eye
                if(trainedleftwink == 1)
                    if(wink_left_SVM == 2)
                        w_council(1) = w_council(1) +1;
                    end
                    if(wink_left_KNN == 2)
                        w_council(1) = w_council(1) +1;
                    end
                    if(wink_left_LDA == 2)
                        w_council(1) = w_council(1) +1;
                    end
                end
                %Right Eye
                if(trainedrightwink == 1)
                    if(wink_right_SVM == 2)
                        w_council(2) = w_council(2) +1;
                    end
                    if(wink_right_KNN == 2)
                        w_council(2) = w_council(2) +1;
                    end
                    if(wink_right_LDA == 2)
                        w_council(2) = w_council(2) +1;
                    end
                end

            %Final Prediction
            if(trainedleftwink == 1 && trainedrightwink == 0)
                wink_right_ensemble = 0;
                q = [1];
            elseif(trainedrightwink == 1 && trainedleftwink == 0)
                wink_left_ensemble = 0;
                q = [2];
            else
                q = [1,2];
            end
            wink_target_meta = [wink_left_ensemble' wink_right_ensemble'];
            wink_guess_ensemble = 0;
            
            %Q is channels
            for i = q
                if(wink_target_meta(1,i) > 1.2 || w_council(i) >= 1)
                     wink_guess_ensemble = i;
                end
            end
        %End Wink Prediction%
        end
        
        if(trainedleftjaw == 1 || trainedrightjaw == 1 || trainedbothjaws == 1)
        %Begin Jaw Analysis
        %Calculate Variance, Power, Ratio of Power
            k = 0;
            for j = jaw_channel_set;
                %use k instead of loop_set, goes from 1-8
                k = k+1;
                %Calculate the variances in all the wink samples
                jaw_var(k) = var(sample(:,j));

                %Fourier Transform of EEG data on specified channel
                F(k,:) = fft(sample(:,j), SAMPLINGRATE);
                jaw_power(k) = 0;

                %Take power of frequencies across 32-48Hz
                for i = 33:49
                    jaw_power(k) = jaw_power(k)+ abs(F(k,i))^2;
                end

                %Normalizing Jaw Power
                jaw_power(k) = jaw_power(k)/16;
                jaw_power_sum = jaw_power_sum + jaw_power(k)/8;
            end

            %Calculating ratios of power
            for j = 1:4
                left_jaw_power = left_jaw_power + jaw_power(j);
                right_jaw_power = right_jaw_power + jaw_power(j+4);
                jaw_var_sum(1) = jaw_var_sum(1) + jaw_var(j);
                jaw_var_sum(2) = jaw_var_sum(2) + jaw_var(j+4);
            end
            jaw_p_ratio(1) = left_jaw_power/right_jaw_power;
            jaw_p_ratio(2) = right_jaw_power/left_jaw_power;
            
            %Calculating ratios of variance
            jaw_var_ratio(1) = jaw_var_sum(1)/jaw_var_sum(2);
            jaw_var_ratio(2) = jaw_var_sum(2)/jaw_var_sum(1);
            
            %Calculating correlation
            sigma_count = 0;
            sigma_count = 0;
            for i = 1:4
                for j = 15-i
                    C = corrcoef(sample(:,i), sample(:,j));
                    jaw_sigma(i) = C(2,1);
                end
            end  
        %End Jaw Analysis
        end
        
        %Begin Jaw Prediction%
            data = [jaw_var_ratio,jaw_sigma, jaw_power_sum',left_jaw_power', right_jaw_power', jaw_p_ratio];

            %Used for calculating the length of the row vectors in data
            data_size = size(data);
            data_param = data_size(2);
            
            %Simulate for Left Jaw
            if(trainedleftjaw == 1)
                %Simulate Logistic Regression Prediction
                jaw_left_LR = 2-1/(1+exp(-dot(j_B_l,[1 data(1,1:data_param)])));
                %Simulate Artificial Neural Network Prediction
                jaw_left_ANN = sim(j_net_l,data(:,1:data_param)'); 
                %Simulate Support Vector Machine Prediction
                jaw_left_SVM = svmclassify(j_SVM_l,data(:,1:data_param));
                %Simulate K Nearest Neighbor Prediction
                jaw_left_KNN = predict(j_KNN_l,data(:,1:data_param));
                %Simulate Linear Discriminant Analysis Prediction
                jaw_left_LDA = predict(j_LDA_l,data(:,1:data_param));
                %Predictions for Training Networks seperated for each Eye 
                j_learning_data_l = [jaw_left_ANN' jaw_left_LR' jaw_left_SVM jaw_left_KNN jaw_left_LDA];
                jaw_left_ensemble = 2-1/(1+exp(-dot(j_B_l_ensemble,[1 j_learning_data_l(1,:)])));
            end
            
            %Simulate for Right Jaw
            if(trainedrightjaw == 1)
                %Simulate Logistic Regression Prediction
                jaw_right_LR = 2-1/(1+exp(-dot(j_B_r,[1 data(1,1:data_param)])));
                %Simulate Artificial Neural Network Prediction
                jaw_right_ANN = sim(j_net_r,data(:,1:data_param)'); 
                %Simulate Support Vector Machine Prediction
                jaw_right_SVM = svmclassify(j_SVM_r,data(:,1:data_param));
                %Simulate K Nearest Neighbor Prediction
                jaw_right_KNN = predict(j_KNN_r,data(:,1:data_param));
                %Simulate Linear Discriminant Analysis Prediction
                jaw_right_LDA = predict(j_LDA_r,data(:,1:data_param));
                %Predictions for Training Networks seperated for each Eye 
                j_learning_data_r = [jaw_right_ANN' jaw_right_LR' jaw_right_SVM jaw_right_KNN jaw_right_LDA];
                jaw_right_ensemble = 2-1/(1+exp(-dot(j_B_r_ensemble,[1 j_learning_data_r(1,:)])));
            end
            
            %Simulate for Both Jaw
            if(trainedbothjaws == 1)
                %Simulate Logistic Regression Prediction
                jaw_both_LR = 2-1/(1+exp(-dot(j_B_b,[1 data(1,1:data_param)])));
                %Simulate Artificial Neural Network Prediction
                jaw_both_ANN = sim(j_net_b,data(:,1:data_param)'); 
                %Simulate Support Vector Machine Prediction
                jaw_both_SVM = svmclassify(j_SVM_b,data(:,1:data_param));
                %Simulate K Nearest Neighbor Prediction
                jaw_both_KNN = predict(j_KNN_b,data(:,1:data_param));
                %Simulate Linear Discriminant Analysis Prediction
                jaw_both_LDA = predict(j_LDA_b,data(:,1:data_param));
                %Predictions for Training Networks seperated for each Eye 
                j_learning_data_b = [jaw_both_ANN' jaw_both_LR' jaw_both_SVM jaw_both_KNN jaw_both_LDA];
                jaw_both_ensemble = 2-1/(1+exp(-dot(j_B_b_ensemble,[1 j_learning_data_b(1,:)])));
            end
            
            %A counter that keeps track of how many Training Machines out
            %of SVM, KNN, and LDA believe it is correct
                j_council(1:3,1:LOOP_NUM) = 0;
                %Left Jaw
                if(trainedleftjaw == 1)
                    if(jaw_left_SVM == 2)
                        j_council(1) = j_council(1) +1;
                    end
                    if(jaw_left_KNN == 2)
                        j_council(1) = j_council(1) +1;
                    end
                    if(jaw_left_LDA == 2)
                        j_council(1) = j_council(1) +1;
                    end
                end
                %Right Jaw
                if(trainedrightjaw == 1)
                    if(jaw_right_SVM == 2)
                        j_council(2) = j_council(2) +1;
                    end
                    if(jaw_right_KNN == 2)
                        j_council(2) = j_council(2) +1;
                    end
                    if(jaw_right_LDA == 2)
                        j_council(2) = j_council(2) +1;
                    end
                end
                %Both Jaw
                if(trainedbothjaws == 1)
                    if(jaw_both_SVM == 2)
                        j_council(3) = j_council(3) +1;
                    end
                    if(jaw_both_KNN == 2)
                        j_council(3) = j_council(3) +1;
                    end
                    if(jaw_both_LDA == 2)
                        j_council(3) = j_council(3) +1;
                    end
                end

            %Final Prediction
            if(trainedleftjaw == 1 && trainedrightjaw == 0 && trainedbothjaws == 0)
                jaw_right_ensemble = 0;
                jaw_both_ensemble = 0;
                q = [1];
            elseif(trainedleftjaw == 1 && trainedrightjaw == 1 && trainedbothjaws == 0)
                jaw_both_ensemble = 0;
                q = [1,2];
            elseif(trainedleftjaw == 1 && trainedrightjaw == 0 && trainedbothjaws == 1)
                jaw_right_ensemble = 0;
                q = [1,3];
            elseif(trainedleftjaw == 0 && trainedrightjaw == 1 && trainedbothjaws == 0)
                jaw_left_ensemble = 0;
                jaw_both_ensemble = 0;
                q = [2];
            elseif(trainedleftjaw == 0 && trainedrightjaw == 1 && trainedbothjaws == 1)
                jaw_left_ensemble = 0;
                q = [2,3];
            elseif(trainedleftjaw == 0 && trainedrightjaw == 0 && trainedbothjaws == 1)
                jaw_left_ensemble = 0;
                jaw_right_ensemble = 0;
                q = [3];
            else
                q = [1,2,3];
            end
            jaw_target_meta = [jaw_left_ensemble' jaw_right_ensemble' jaw_both_ensemble'];
            jaw_guess_ensemble = 0;
            
            %Q is channels
            for i = q
                if(jaw_target_meta(1,i) > 1.2 || j_council(i) >= 1)
                     jaw_guess_ensemble = i;
                end
            end
        %End Jaw Prediction%
        
        %Control movement of Robotic Arm
        if(wink_guess_ensemble ~= 0)
            if(wink_guess_ensemble == 1)
                display('You committed a left wink');
            elseif(wink_guess_ensemble == 2)
                display('You committed a right wink');
            end
        end
        
        %Give time to EEG Emotiv Headset to collect new values, do not
        %want to load values all the time or else leads to the detection of 
        %one movement more than once. Also, gives a chance for the
        %stop_CB to stop run_CB
        pause(0.5);
        counter = counter + 1;
        %At end of loop check whether it should be ran through the loop another time
        params = guidata(source);
        run = params.run;
        guidata(source,params);
    end
    a.Stop;
    delete(a);
end
