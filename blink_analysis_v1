function[blink] = blink_analysis(SAMPLES,filt_sample,LOOP_NUM)

%% analysis - checking for blink w/ correlation - live stream input sample

% variables that come from outside this function:
% SAMPLES
% filt_sample
% LOOP_NUM

% variables to come out of the function
% blink(LOOP_NUM)

% no splitting into segments, only one segment
% 
SEGMENT_SIZE = SAMPLES;
n = 1:1:SAMPLES;

%how many channels are used in the 1st analysys
ANALYSIS_1_CHANNELS = 6;

%zero out some cool things
k = 0;
sum_mean(LOOP_NUM) = 0;
sum_power(LOOP_NUM) = 0;
sum_max(LOOP_NUM) = 0;
var_sum(LOOP_NUM) = 0;
var_filt_sum(LOOP_NUM) = 0;

for q = [1,2,4,11,13,14];

    %instead of using 1,2,4,11,13,14 it now goes 1-6
    k = k+1;     
    %initialize sum value
    sum(k) = 0;    
         % split the sample into segments, not strictly necessary, kind of
         % handy I guess, could replace entire code with filt_sample(j,q)
         % instead of segment(k,j)
         for j = 1:SEGMENT_SIZE
             segment(k,j) = filt_sample(j,q);
             sum(k) = sum(k) + segment(k,j);
         end     
        
    % find the mean and the power
    mean(k) = sum(k)/SEGMENT_SIZE;
    power(k) = mean(k)^2;
    sum_mean(LOOP_NUM) = sum_mean(LOOP_NUM) + mean(k)/ANALYSIS_1_CHANNELS;
    sum_power(LOOP_NUM) = sum_power(LOOP_NUM) + power(k)/ANALYSIS_1_CHANNELS;
    % determine what the max value is and where it occurs
    [max_val(k), max_ind(k)] = max(segment(k,:));
    % calculate the average of a few samples around the max value, and
    % compare that to the mean value.
    near_max(k) = 0;
     
      % calculate the stuff
      for i = 1:11
         near_max(k) = near_max(k) + segment(k,max(1,min(SEGMENT_SIZE,(max_ind(k) - 5 + i))))/11;
      end 
    sum_max(LOOP_NUM) = sum_max(LOOP_NUM) + near_max(k)/ANALYSIS_1_CHANNELS;
    
    
    % probability shit time!
    
    %simple variation
    var_sample(k) = var(segment(k,:));
    var_sum(LOOP_NUM) = var_sum(LOOP_NUM) + var_sample(k);
    
    %remove place where program thinks you blinked, recheck variation,
    %should be low
    filt_seg(k,:) = segment(k,:);
    for j = 1:36
        % this is a fun line. the max and min functions make sure it is
        % bounded by the indexes of the segment, ensuring there are no out
        % of bounds errors. It then moves from the index of the peak value
        % and flattens an area around the peak to the mean. If the peak was
        % the major cause of variation in the sample, this should
        % drastically reduce the variation
        filt_seg(k,max(1,min(SEGMENT_SIZE,(max_ind(k) - 10 + j)))) = mean(k);
    end
    
   
    
    %recheck the variation after filtering out the peak
    var_filt_sample(k) = var(filt_seg(k,:));
    var_filt_sum(LOOP_NUM) = var_filt_sum(LOOP_NUM) + var_filt_sample(k);
end

var_ratio(LOOP_NUM) = var_sum(LOOP_NUM) / var_filt_sum(LOOP_NUM);


% calculate the correlation of the signal
cor_sum(LOOP_NUM) = 0;
for k = 1:ANALYSIS_1_CHANNELS-1; 
    for x = (k+1):ANALYSIS_1_CHANNELS
         cor_data(k,x) = correlation(segment(k,:), segment(x,:));
         cor_sum(LOOP_NUM) = cor_sum(LOOP_NUM) + cor_data(k,x);
    end
end
    
% now is the fun part! Decide if they blinked, or not!

% check the straight sum, make sure the maximum is higher than the mean
if((sum_max(LOOP_NUM) - sum_mean(LOOP_NUM) > 30))
    
    %check the variances, make sure it dropped after filtering
    if(var_ratio(LOOP_NUM) > 3)
       
        %we won the lottery and found a blink! (probably)
        blink(LOOP_NUM) = 1;        
        figure;
            i = 0;
            for j = [1,2,4,11,13,14]
                i = i +1;
                subplot(2,3,i);
                plot(n,filt_sample(:,j));
            end
    end
else
    blink(LOOP_NUM) = 0;
end

blink = blink(LOOP_NUM);

end
