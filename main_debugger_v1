clear all

%% Old Data


% [hdr, record] = edfread('Ryan-eyebrow raise x3-31.10.13.18.45.10.edf');
% [hdr, record] = edfread('Ryan-Left Bicep relaxed-clenched-relaxed-31.10.13.18.13.14.edf');
% [hdr, record] = edfread('Ryan-left hand clench x3-31.10.13.18.50.00.edf');

% algorithm picks this one up, why? - 2 of the 8 electrodes used were
% terrible that day, hence picking up / not picking up data
% [hdr, record] = edfread('Ryan -Blink x 3-31.10.13.17.57.19.edf');
% [hdr, record] = edfread('Ryan-left jaw clench x3-31.10.13.18.20.15.edf');
% [hdr, record] = edfread('Ryan-lift left arm x3-31.10.13.18.05.22.edf');
% [hdr, record] = edfread('Ryan-Eyes open-closed-open-31.10.13.18.03.32.edf');

% [hdr, record] = edfread('Ryan-lift right arm x3-31.10.13.18.06.18.edf');
% [hdr, record] = edfread('Ryan-Right Bicep relaxed-clenched-relaxed-31.10.13.18.11.41.edf');
% [hdr, record] = edfread('Ryan-right hand clench x3-31.10.13.18.49.21.edf');
% [hdr, record] = edfread('Ryan-right jaw clench x3-31.10.13.18.21.10.edf');

% new data
% [hdr, record] = edfread('Ryan-blink x 5 -num1-16.11.13.14.34.31.edf');
% [hdr, record] = edfread('Ryan-Blink x 5 num2-16.11.13.14.35.06.edf');
% [hdr, record] = edfread('Ryan-blink x 5 num3-16.11.13.14.35.43.edf');
% [hdr, record] = edfread('Ryan-blink x 5 num4-16.11.13.14.36.33.edf');
% [hdr, record] = edfread('Ryan-blink x 5 num5-16.11.13.14.37.10.edf');
% [hdr, record] = edfread('Ryan-alpha_rhythm_x1-21.11.13.17.53.31.edf');

% [hdr, record] = edfread('Ryan-jaw_clench_x9-21.11.13.17.57.19.edf');
% [hdr, record] = edfread('Ryan-left_jaw_clench_x10-21.11.13.18.00.04.edf');
% [hdr, record] = edfread('Ryan-mixofjclench-28.11.13.17.35.54.edf');
%[hdr, record] = edfread('Ryan-right_jaw_clench_x10-21.11.13.18.00.49.edf');

% [hdr, record] = edfread('Ryan-Left-28.11.13.17.29.12.edf');
% [hdr, record] = edfread('Ryan-Right-28.11.13.17.30.41.edf');
% [hdr, record] = edfread('Ryan-Feet-28.11.13.17.34.27.edf');

%[hdr, record] = edfread('Ryan-Hands-28.11.13.22.12.10.edf');

% Data that has markers in them


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %Jaw stuff
% %jaw movement Nov 28
% %[hdr, record1] = edfread('Ryan-jawmov1-28.11.13.22.01.35.edf');
% %jaw movement Feb 7, 2014
% [hdr, record5] = edfread('RyanJaw-3Feb7-07.02.14.15.48.33.edf');
% [hdr, record6] = edfread('Ryan-1Feb7-07.02.14.15.41.19.edf');
% %jaw movement Feb 9, 2014
% [hdr, record7] = edfread('JawFeb9.edf');
% [hdr, record8] = edfread('Jaw2Feb9.edf');
% 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Winking stuff
% % winking Feb 7, 2014
% [hdr, record2] = edfread('RyanWink4Feb7.edf');
% 
% % unusable when jaw clench is also being used
% [hdr, record1] = edfread('RyanWink-2Feb7-07.02.14.15.45.22.edf');
% 
% 
% % winking feb 9
% [hdr, record3] = edfread('WinkFeb9.edf');
% [hdr, record4] = edfread('Wink2Feb9.edf');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Mu Stuff
% mu data Dec 22
% [hdr, record1] = edfread('Ryan-mixmu-22.12.13.16.23.55.edf');
% [hdr, record2] = edfread('Ryan-righthand-22.12.13.16.21.46.edf');
% [hdr, record3] = edfread('Ryan-leftfoot-22.12.13.16.19.53.edf');
% [hdr, record4] = edfread('Ryan-rightfoot-22.12.13.16.18.14.edf');
% [hdr, record5] = edfread('Ryan-leftmu-22.12.13.16.12.03.edf');

% Mu data Jan 16 2014
% [hdr, record1] = edfread('Ryan-MixofMovements-16.01.14.17.18.45.edf');
% [hdr, record2] = edfread('Ryan-MixofMove2-16.01.14.17.22.16.edf');
% [hdr, record3] = edfread('Ryan-MixofMove3-16.01.14.17.25.21.edf');
% [hdr, record4] = edfread('Ryan-MixMove4-16.01.14.17.28.11.edf');
% [hdr, record5] = edfread('Ryan-MixofMove5-16.01.14.17.30.59.edf');

% [hdr, record6] = edfread('Ryan-MixArms-16.01.14.17.39.37.edf');
% [hdr, record7] = edfread('Ryan-Handclench-16.01.14.17.36.01.edf');

%record = [record1 record2 record3 record4 record5];
%record = [record1 record2 record3];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %Eye Alpha Stuff
% % Eye data Feb 21
% [hdr, record1] = edfread('RyanAlphaFeb21-1.edf');
% [hdr, record2] = edfread('RyanAlphaFeb21-2.edf');

% Eye Data March 8
[hdr, record1] = edfread('RyanAlphaMarch8-2.edf');
[hdr, record2] = edfread('RyanAlphaMarch8.edf');
[hdr, record3] = edfread('arturoalphaMarch8-2.edf');
[hdr, record4] = edfread('arturoalphaMarch8.edf');


%% HUGE loop, runs two things, first to train, then to test

for OUTER_LOOP = 1:2

%% Params 

%important that there are more samples in second one than first one
if(OUTER_LOOP == 1)
    record = [record2];
else 
    record = [record1 record4 record3];
end
%record = record1;

CHANNELS = 14;
BANDS = 8;
m = 1:1:CHANNELS;

markers = record(36,:);
left_jaw_bool = 0;
right_jaw_bool = 0;
both_jaws_bool = 0;
closed = 0;

left_hand_bool = 0;
right_hand_bool = 0;

% for j = 1:CHANNELS
%     figure;
%     plot(record(j+2,:));
% end

LOOP_NUM = 0;
counter = 0;

%% big mother loop

%% 128 bit window Loop
% SAMPLES = 128;
% while((SAMPLES*(counter+1)) <= length(record))
% sample = record(3:16,(SAMPLES*(counter)+1:(SAMPLES*(counter +1))))';
% LOOP_NUM = LOOP_NUM+1;

   
%% 64 Bit Window Loop
SAMPLES = 64;
while((SAMPLES*(counter+1) + 64) <= length(record))   
    sample = record(3:16,(SAMPLES*(counter)+1:(SAMPLES*(counter +1) +64)))';
    LOOP_NUM = LOOP_NUM+1;

%% Transforms and Filters
% for q = 1:CHANNELS
%     for j = 1:SAMPLES 
%         min_sample(q) = min(sample(:,q));
%         zeroed_sample(j,q) = sample(j,q) - min_sample(q);
%     end
% end
% 
% for j = 1:CHANNELS
%     cwt_data(:,:,j) = cwt(sample(:,j), 1:64, 'sym8');
%     F(:,j) = fft(sample(:,j));
%     F(1:floor((SAMPLES/5)),j) = 0;
%     filt_sample(:,j) = ifft(F(:,j));
%     [dwt_data(:,j),L(:,j)] = wavedec(sample(:,j),BANDS,'sym8');
% end
% 
% for j = 1:CHANNELS
%     DCELL(:,j) = detcoef(dwt_data(:,j), L(:,j), [1:BANDS]);
% end
% 
% 
% for j = 1:BANDS
%     ratio(j) = length(DCELL{1,1}) / length(DCELL{j,1});
% end
% 
% for q = 1:CHANNELS
%     for j = 1:BANDS
%         for i = 1:length(DCELL{1,1});
%             D(j,i,q) = DCELL{j,q}(  min (length(DCELL{j,1}),(ceil(i/ratio(j)))));
%         end
%     end
% end

% to get a double out of a cell use DCELL{i,j}
%% analysis - checking for blink w/ correlation - live stream input sample
% 
% % variables that come from outside this function:
% % SAMPLES
% % filt_sample
% % LOOP_NUM
% 
% % variables to come out of the function
% % blink_out (either 1 or 0)
% 
% % no splitting into segments, only one segment
% % 
% SEGMENT_SIZE = SAMPLES;
% 
% %how many channels are used in the 1st analysys
% ANALYSIS_1_CHANNELS = 8;
% 
% %zero out some cool things
% k = 0;
% sum_mean(LOOP_NUM) = 0;
% sum_power(LOOP_NUM) = 0;
% sum_max(LOOP_NUM) = 0;
% var_sum(LOOP_NUM) = 0;
% var_filt_sum(LOOP_NUM) = 0;
% 
% for q = [1,2,3,4,11,12,13,14];
% 
%     %instead of using 1,2,3,4,11,12,13,14 it now goes 1-8
%     k = k+1;     
%     %initialize sum value
%     sum(k) = 0;    
%          % split the sample into segments, not strictly necessary, kind of
%          % handy I guess, could replace entire code with filt_sample(j,q)
%          % instead of segment(k,j)
%          for j = 1:SEGMENT_SIZE
%              segment(k,j) = filt_sample(j,q);
%              sum(k) = sum(k) + segment(k,j);
%          end     
%         
%     % find the mean and the power
%     mean(k) = sum(k)/SEGMENT_SIZE;
%     power(k) = mean(k)^2;
%     sum_mean(LOOP_NUM) = sum_mean(LOOP_NUM) + mean(k)/ANALYSIS_1_CHANNELS;
%     sum_power(LOOP_NUM) = sum_power(LOOP_NUM) + power(k)/ANALYSIS_1_CHANNELS;
%     % determine what the max value is and where it occurs
%     [max_val(k), max_ind(k)] = max(segment(k,:));
%     % calculate the average of a few samples around the max value, and
%     % compare that to the mean value.
%     near_max(k) = 0;
% 
%     % calculate the stuff
%     for i = 1:11
%      near_max(k) = near_max(k) + segment(k,max(1,min(SEGMENT_SIZE,(max_ind(k) - 5 + i))))/11;
%     end 
%     sum_max(LOOP_NUM) = sum_max(LOOP_NUM) + near_max(k)/ANALYSIS_1_CHANNELS;
%     
%     
%     % probability shit time!
%     
%     %simple variation
%     var_sample(k) = var(segment(k,:));
%     var_sum(LOOP_NUM) = var_sum(LOOP_NUM) + var_sample(k);
%     
%     %remove place where program thinks you blinked, recheck variation,
%     %should be low
%     filt_seg(k,:) = segment(k,:);
%     for j = 1:36
%         % this is a fun line. the max and min functions make sure it is
%         % bounded by the indexes of the segment, ensuring there are no out
%         % of bounds errors. It then moves from the index of the peak value
%         % and flattens an area around the peak to the mean. If the peak was
%         % the major cause of variation in the sample, this should
%         % drastically reduce the variation
%         filt_seg(k,max(1,min(SEGMENT_SIZE,(max_ind(k) - 10 + j)))) = mean(k);
%     end

%    
%     
%     %recheck the variation after filtering out the peak
%     var_filt_sample(k) = var(filt_seg(k,:));
%     var_filt_sum(LOOP_NUM) = var_filt_sum(LOOP_NUM) + var_filt_sample(k);
% end
% 
% var_ratio(LOOP_NUM) = var_sum(LOOP_NUM) / var_filt_sum(LOOP_NUM);
% 
% 
% % calculate the correlation of the signal
% cor_sum(LOOP_NUM) = 0;
% for k = 1:ANALYSIS_1_CHANNELS-1; 
%     for x = (k+1):ANALYSIS_1_CHANNELS
%          cor_data(k,x) = correlation(segment(k,:), segment(x,:));
%          cor_sum(LOOP_NUM) = cor_sum(LOOP_NUM) + cor_data(k,x);
%     end
% end
%     
% % now is the fun part! Decide if they blinked, or not!
% 
% % check the straight sum, make sure the maximum is higher than the mean
% if((sum_max(LOOP_NUM) - sum_mean(LOOP_NUM) > 15))
%     
%     %check the variances, make sure it dropped after filtering
%     if(var_ratio(LOOP_NUM) > 3)
%        
%         %we won the lottery and found a blink! (probably)
%         blink(LOOP_NUM) = 1;        
%         figure;
%         for j = 1:CHANNELS
%             subplot(6,3,j);
%             ylabel(sprintf('Channel %d' ,j));
%             plot(n, filt_sample(:,j));
%         end
%     end
% else
%     blink(LOOP_NUM) = 0;
% end
%% Analysis/training - Eyes open/closed

%Determines if eyes are open or closed
%Check if O1 (channel 7) 9 Hz power is greater than a threshold
    
    %reading sample from record
    %sample = simout(:,2:15)';
    LOOP_SET_WINK = [7 8];
    
    %Code to convert marker into open/closed
    marky_mark_eyes = max(record(36,(SAMPLES*(counter)+1:(SAMPLES*(counter +1) + 64))));
    if (marky_mark_eyes==60)
        closed = 1;
    elseif (marky_mark_eyes==61)
        closed = 0;
    end
    if(closed == 1)
        eyes_closed(LOOP_NUM) = 2;
    elseif (closed == 0)
        eyes_closed(LOOP_NUM) = 1;
    end
    
    k = 0;
    for j = LOOP_SET_WINK
            k = k+1;
            F(k,:) = fft(sample(:,j));
    end
    
    sum_alphapower(LOOP_NUM) = 0;
    for j = 1:2
        alphapower(LOOP_NUM,j) = 0;
        %average across 9-11hz, location of alpha band
        for i = 9:13
            alphapower(LOOP_NUM,j) = alphapower(LOOP_NUM,j) + abs(F(j,i))^2;
        end
        sum_alphapower(LOOP_NUM) = sum_alphapower(LOOP_NUM) + alphapower(LOOP_NUM,j);
    end
%% Analysis - Winking
% %Stuff goes here
% 
% % %calculate which event occured
% % calculate where the markers are
% marky_mark = max(record(36,(SAMPLES*(counter)+1:(SAMPLES*(counter +1) + 64))));
% 
% if (marky_mark == 40)
%     wink_right(LOOP_NUM) = 1;
%     wink_left(LOOP_NUM) = 2;
%     wink_out(LOOP_NUM) = 1;
% elseif (marky_mark == 50)
%     wink_right(LOOP_NUM) = 2;
%     wink_left(LOOP_NUM) = 1;
%     wink_out(LOOP_NUM) = 2;
% else
%     wink_right(LOOP_NUM) = 1;
%     wink_left(LOOP_NUM) = 1;
%     wink_out(LOOP_NUM) = 0;
% end
% 
% 
% %set of electrodes to cover
% WINK_LOOP_SET = [2,13];
% 
% %Calculate Variance, Power, Ratio of Power
% k = 0;
% for i = WINK_LOOP_SET;
%     %use k instead of loop_set, goes from 1-2
%     k = k+1;
%     
%     %Calculate the variances in all the wink samples
%     wink_var(LOOP_NUM,k) = var(sample(:,i));
%     
%     w_F(k,:) = fft(sample(:,i));
%     w_F(k,1) = 0;
% 
%     wink_power(LOOP_NUM,k) = 0;
%     
%     %selects frequencies from 10-20 Hz
%     for j = 10:20;
%         wink_power(LOOP_NUM,k) = wink_power(LOOP_NUM,k)+ abs(w_F(k,j))^2;
%     end
%     
%     wink_peak(LOOP_NUM,k) = 0;
%     [Y,ind] = max(sample(:,i));
%     for q = 1:10
%         wink_peak(LOOP_NUM,k) = wink_peak(LOOP_NUM,k)+ abs(sample(min(max((ind-3)+q,1),127),i));
%     end
% end
% 
% % calculate ratio of powers (uneccessary)
% wink_p_ratio(LOOP_NUM,1) = wink_power(LOOP_NUM,1) / wink_power(LOOP_NUM,2);
% wink_p_ratio(LOOP_NUM,2) = wink_power(LOOP_NUM,2) / wink_power(LOOP_NUM,1);
% 
% wink_peak_ratio(LOOP_NUM,1) = wink_peak(LOOP_NUM,2) / wink_peak(LOOP_NUM,1);
% 
% % calculate ratio of variances (uneccessary)
% wink_v_ratio(LOOP_NUM,1) = wink_var(LOOP_NUM,1) / wink_var(LOOP_NUM,2);
% wink_v_ratio(LOOP_NUM,2) = wink_var(LOOP_NUM,2) / wink_var(LOOP_NUM,1);
% 
% % calculate correlation
% 
% % CALCULATE CORRELATION
% % use following instead of 1:14 for specific channels only i = [2,13]
% sigma_count = 0;
% for i = WINK_LOOP_SET
%     for j = WINK_LOOP_SET
%         if(i ~= j && j > i)
%             sigma_count = sigma_count+1;
%             C = corrcoef(sample(:,i), sample(:,j));
%             wink_sigma(LOOP_NUM,sigma_count) = C(2,1);
%         end
%     end
% end    
%% analysis - jaw state
% %determines if the subject is clenching their jaw
% %inputs: LOOP_NUM, sample
% %*the variable sample needs to have 128 samples exactly*
% %outputs: jaws_clenched
% 
% %first thing that has to be done is some filtering
% %take frequencies above 32hz, when you clench your jaw it's high frequency
% %and high power.
% jaw_power(LOOP_NUM) = 0;
% k = 0;
% jaw_power_sum(LOOP_NUM) = 0;
% 
% LOOP_SET_JAW = [1,2,3,4,11,12,13,14];
% 
% for j = LOOP_SET_JAW;
%     %instead of using 1,2,3,4,11,12,13,14 it now goes 1-8
%     
%     % Calculate the variances in all the jaw samples
%     k = k+1; 
%     jaw_var(LOOP_NUM,k) = var(sample(:,j));
%     
%     F(k,:) = fft(sample(:,j));
%     jaw_power(LOOP_NUM,k) = 0;
%     
%     %selects frequencies from 32-48 Hz
%     for i = 33:49;
%         jaw_power(LOOP_NUM,k) = jaw_power(LOOP_NUM,k)+ abs(F(k,i))^2;
%     end
%     
%     %normalize for the range of frequencies being sampled, in this case
%     %looking at 16 frequencies
%     jaw_power(LOOP_NUM,k) = jaw_power(LOOP_NUM,k)/16;
%     jaw_power_sum(LOOP_NUM) = jaw_power_sum(LOOP_NUM) + jaw_power(LOOP_NUM,k)/8;
% end
% 
% % CALCULATE CORRELATION
% % use following instead of 1:14 for specific channels only: [1,2,3,4,11,12,13,14];
% sigma_count = 0;
% for i = 1:4
%     for j = 15-i
%        C = corrcoef(sample(:,i), sample(:,j));
%        jaw_sigma(LOOP_NUM,i) = C(2,1);
%     end
% end   
% 
% %determine powers in the right and left jaws as well as the ratio between
% %them. At the same time determine the same stuff for variances.
% left_jaw_power(LOOP_NUM) = 0;
% right_jaw_power(LOOP_NUM) = 0;
% jaw_var_sum(LOOP_NUM,1:2) = 0;
% for j = 1:4
%     left_jaw_power(LOOP_NUM) = left_jaw_power(LOOP_NUM) + jaw_power(LOOP_NUM,j);
%     right_jaw_power(LOOP_NUM) = right_jaw_power(LOOP_NUM) + jaw_power(LOOP_NUM,j+4);
%     jaw_var_sum(LOOP_NUM,1) = jaw_var_sum(LOOP_NUM,1) + jaw_var(LOOP_NUM,j);
%     jaw_var_sum(LOOP_NUM,2) = jaw_var_sum(LOOP_NUM,2) + jaw_var(LOOP_NUM,j+4);
% end
% jaw_p_ratio(LOOP_NUM,1) = left_jaw_power(LOOP_NUM)/right_jaw_power(LOOP_NUM);
% jaw_p_ratio(LOOP_NUM,2) = right_jaw_power(LOOP_NUM)/left_jaw_power(LOOP_NUM);
% jaw_var_ratio(LOOP_NUM,1) = jaw_var_sum(LOOP_NUM,1)/jaw_var_sum(LOOP_NUM,2);
% jaw_var_ratio(LOOP_NUM,2) = jaw_var_sum(LOOP_NUM,2)/jaw_var_sum(LOOP_NUM,1);
% 
% if(left_jaw_bool == 1)
%     left_jaw_clench(LOOP_NUM) =2;
%     right_jaw_clench(LOOP_NUM) =1; 
%     jaws_clenched(LOOP_NUM) = 1;
%     jaw_out(LOOP_NUM) = 3; 
% elseif(right_jaw_bool == 1)
%     right_jaw_clench(LOOP_NUM) =2;  
%     left_jaw_clench(LOOP_NUM) =1;
%     jaws_clenched(LOOP_NUM) = 1;
%     jaw_out(LOOP_NUM) = 2; 
% elseif(both_jaws_bool == 1)
%     jaws_clenched(LOOP_NUM) = 2;
%     left_jaw_clench(LOOP_NUM) =1;
%     right_jaw_clench(LOOP_NUM) =1; 
%     jaw_out(LOOP_NUM) = 1; 
% else
%     left_jaw_clench(LOOP_NUM) =1;
%     right_jaw_clench(LOOP_NUM) =1; 
%     jaws_clenched(LOOP_NUM) = 1;
%     jaw_out(LOOP_NUM) = 0;     
% end
% 
% %calculate which event occured
% 
% marky_mark = max(record(36,(SAMPLES*(counter)+1:(SAMPLES*(counter +1) + 64))));
%     
% if (marky_mark == 10)
%     left_jaw_bool = 1;
%     left_jaw_clench(LOOP_NUM) =2;
% elseif (marky_mark == 11)
%     left_jaw_bool = 0;
% elseif (marky_mark == 20)
%     right_jaw_bool = 1;
%     right_jaw_clench(LOOP_NUM) =2;
% elseif (marky_mark == 21)
%     right_jaw_bool = 0;
% elseif (marky_mark == 30)
%     both_jaws_bool = 1;
%     jaws_clenched(LOOP_NUM) =2;
% elseif (marky_mark == 31)
%     both_jaws_bool = 0;
% end
%      
%% analysis - Mu desynch
% 
% count = LOOP_NUM;
% eegdata = record;
% 
% LOOP_SET = [4 5 10 11];
% 
% % for i = LOOP_SET
% %     cwt_data(:,:,i) = cwt(sample(:,i), 1:8, 'sym8');
% % end
% % 
% % waveletFunction = 'db8'; %OR 'sym8' OR 'coif5' OR 'db4'
% % 
% % for i = LOOP_SET
% %     [C,L] = wavedec(sample(:,i),8,waveletFunction); %DIVIDES INTO 8 BANDS
% %     % Calculation The Coefficients Vectors
% %     cD1(i,:) = detcoef(C,L,1);                   %64-32 Gamma bands
% %     cD2(i,:) = detcoef(C,L,2);                   %32-16 Gamma and some Beta bands
% %     cD3(i,:) = detcoef(C,L,3);                   %16-8 Alpha and Mu bands
% %     cD4(i,:) = detcoef(C,L,4);                   %8-4 Theta band
% %     cD5(i,:) = detcoef(C,L,5);                   %4-2Hz Delta band /GARBAGE
% %     cD6(i,:) = detcoef(C,L,6);                   %GARBAGE
% %     cD7(i,:) = detcoef(C,L,7);                   %GARBAGE
% %     cD8(i,:) = detcoef(C,L,8);                   %GARBAGE
% % end
% % 
% % %CALCULATE CORRELATION OF MU BANDS
% % sigma_mu_count = 0;
% % for i = LOOP_SET
% %     for j = LOOP_SET
% %         if(i ~= j && j > i)
% %             sigma_mu_count = sigma_mu_count+1;
% %             C = corrcoef(cD3(i,:), cD3(j,:));
% %             wavelet_corr(sigma_mu_count, count) = C(2,1);
% %         end
% %     end
% % end  
% 
% 
% % use FDAtool to generate a MATLAB script which implements a filter, much
% % easier than simulink. Filter the sample.
% 
%  %  sample(:,:) = mu_filter(sample(:,:));
%  
% % calculate variances
% k = 0;
% for i = LOOP_SET
%    k = k+1;
%    mu_var(k, count) = var(sample(:,i));
% end   
% 
% % calculate ratio of variances
% k = 0;
% for k = 1:2
%    mu_var_ratio(k, count) = mu_var(k, count)/mu_var(k+2, count);
% end   
% 
% % CALCULATE CORRELATION
% % use following instead of 1:14 for specific channels only i = [4 5 6 9 10 11]
% sigma_count = 0;
% for i = LOOP_SET
%     for j = LOOP_SET
%         if(i ~= j && j > i)
%             sigma_count = sigma_count+1;
%             C = corrcoef(sample(:,i), sample(:,j));
%             mu_corr(sigma_count, count) = C(2,1);
%         end
%     end
% end           
% 
% % calculate powers
% F_sample = fft(sample);
% 
% k = 0;
% for i = LOOP_SET
%     k = k+1;
%     mu_pow(k,count) = 0;
%     for x = 5:20
%         mu_pow(k,count) = mu_pow(k,count) + (abs(F_sample(x,i))).^2;
%     end
% end
% 
% % calculate where the markers are
% mu_marker(count) = max(record(36,(SAMPLES*(counter)+1:(SAMPLES*(counter +1)+64))));
% 
% 
% mu_target(count,1:4) = 1;
% 
% if (mu_marker(count)==1 );
%     mu_target(count,1)=2;
% elseif (mu_marker(count)==2 );
%     mu_target(count,2) = 2;
% elseif (mu_marker(count)==3 );
%     mu_target(count,3) = 2;
% elseif (mu_marker(count)==4 );
%     mu_target(count,4)= 2;
% else
%     %DONOTHING
% end
%% Plots

% 
% figure;
% for j = 1:CHANNELS
%     subplot(6,3,j);
%     mesh(cwt_data(:,:,j));
% end

% if(LOOP_NUM == 5)
% 
% figure;
% i = 0;
% for j = [1,2,3,4,11,12,13,14]
%     i = i +1;
%     subplot(2,4,i);
%     plot(n, filt_sample(:,i));
% end
% 
% end

% figure;
% plot(n,zeroed_sample(:,1));



% for j = 1:CHANNELS
%     figure;
%     subplot(4,1,1)
%     mesh(cwt_data(:,:,j));
%     subplot(4,1,2);
%     plot(n,sample(:,j));
%     subplot(4,1,3);
%     mesh(D(:,:,j));
%     subplot(4,1,4);
%     F(1,j) = 0;
%     plot(n,F(:,j));
% end
%% end of loop
%increment counter
counter = counter +1;
                                                                   
end

%% some looking at post data shit - blink or not
% data = [cor_sum',var_sum', var_filt_sum',var_ratio',blink', sum_mean',sum_power',sum_max'];
% 
% 
% blink_cell_data(1,1:9) = {'','Correlation','Variance','Post-Filter Variance','Ratio of Variance','Boolean Blink','Mean','Power','Sum of Maximum'};
% blink_cell_data(2:LOOP_NUM+1,1) = num2cell(1:LOOP_NUM);
% blink_cell_data(2:LOOP_NUM+1,2:9) = num2cell(data);
%% post run looking at things - eyes open or not
e_data = [alphapower];
e_data_size = size(e_data);
e_data_param = e_data_size(2);

if (OUTER_LOOP==1)
    % train Machine Learning
    eyes_SVM = svmtrain(e_data',eyes_closed,'autoscale','true','kernel_function','rbf','Showplot','True');
    eyes_KNN = ClassificationKNN.fit(e_data(:,1:e_data_param),eyes_closed,'NumNeighbors',20);
    eyes_LDA = ClassificationDiscriminant.fit(e_data(:,1:e_data_param),eyes_closed);
elseif(OUTER_LOOP==2)
    eyes_KNN_out = predict(eyes_KNN,e_data);
    eyes_LDA_out = predict(eyes_LDA,e_data);
    eyes_SVM_out = svmclassify(eyes_SVM,e_data);
    for i = 1:LOOP_NUM
        e_council(i) = (eyes_KNN_out(i) + eyes_LDA_out(i) + eyes_SVM_out(i) -3);
    end
    STUFF = [eyes_closed' eyes_SVM_out eyes_KNN_out eyes_LDA_out e_council'];
end
%% post run looking at things + training + ROC Curve - Jaw Clench

% 
% 
% %data = [jaw_var_ratio,jaw_sigma, jaw_power_sum', left_jaw_power', right_jaw_power', jaw_p_ratio];
% data = [jaw_var_ratio,jaw_sigma, jaw_power_sum',left_jaw_power', jaw_p_ratio];
% data_size = size(data);
% data_param = data_size(2);
% 
% %[COEFF,SCORE,latent] = pca(data);
% 
% % COEFF = COEFF';
% % for i = 1:LOOP_NUM
% %         data(i,:) = (COEFF')*data(i,:)';
% % end
% % data_param = 2;
%       
% 
% % training for left
% training_target_l = left_jaw_clench';
% 
% % training for right
% training_target_r = right_jaw_clench';
% 
% % training for both
% training_target_b = jaws_clenched';
% 
% 
% % take into account training and practice runs
% if (OUTER_LOOP == 1)
%     B_l = mnrfit(data(:,1:data_param),training_target_l);
%     j_net_l = feedforwardnet(5);
%     j_net_l.trainParam.showWindow = 0;
%     j_net_l = train(j_net_l,data(:,1:data_param)',training_target_l');   
%     j_SVM_l = svmtrain(data(:,1:data_param)',training_target_l,'autoscale','true','kernel_function','rbf');
%     j_KNN_l = ClassificationKNN.fit(data(:,1:data_param),training_target_l,'NumNeighbors',20);
%     j_LDA_l = ClassificationDiscriminant.fit(data(:,1:data_param),training_target_l);
%     
%     B_r = mnrfit(data(:,1:data_param),training_target_r);
%     j_net_r = feedforwardnet(5);
%     j_net_r.trainParam.showWindow = 0;
%     j_net_r = train(j_net_r,data(:,1:data_param)',training_target_r');  
%     j_SVM_r = svmtrain(data(:,1:data_param)',training_target_r,'autoscale','true','kernel_function','rbf');
%     j_KNN_r = ClassificationKNN.fit(data(:,1:data_param),training_target_r,'NumNeighbors',20);
%     j_LDA_r = ClassificationDiscriminant.fit(data(:,1:data_param),training_target_r);
%     
%     B_b = mnrfit(data(:,1:data_param),training_target_b);
%     j_net_b = feedforwardnet(5);
%     j_net_b.trainParam.showWindow = 0;
%     j_net_b = train(j_net_b,data(:,1:data_param)',training_target_b');   
%     j_SVM_b = svmtrain(data(:,1:data_param)',training_target_b,'autoscale','true','kernel_function','rbf');
%     j_KNN_b = ClassificationKNN.fit(data(:,1:data_param),training_target_b,'NumNeighbors',20);
%     j_LDA_b = ClassificationDiscriminant.fit(data(:,1:data_param),training_target_b);
%     
%     jaw_B = [B_l B_r B_b];  
%     %load('jaw_ANN_Feb19.mat');
% else
%     B_l = jaw_B(:,1);
%     B_r = jaw_B(:,2);
%     B_b = jaw_B(:,3);
% end
% 
% 
% 
% jaw_left_ANN = sim(j_net_l,data(:,1:data_param)');
% jaw_right_ANN = sim(j_net_r,data(:,1:data_param)');
% jaw_both_ANN = sim(j_net_b,data(:,1:data_param)');
% 
% 
% jaw_left_SVM = svmclassify(j_SVM_l,data(:,1:data_param));
% jaw_right_SVM = svmclassify(j_SVM_r,data(:,1:data_param));
% jaw_both_SVM = svmclassify(j_SVM_b,data(:,1:data_param));
% 
% jaw_left_KNN = predict(j_KNN_l,data(:,1:data_param));
% jaw_right_KNN = predict(j_KNN_r,data(:,1:data_param));
% jaw_both_KNN = predict(j_KNN_b,data(:,1:data_param));
% 
% jaw_left_LDA = predict(j_LDA_l,data(:,1:data_param));
% jaw_right_LDA = predict(j_LDA_r,data(:,1:data_param));
% jaw_both_LDA = predict(j_LDA_b,data(:,1:data_param));
% 
% for i=1:LOOP_NUM
%     jaw_left_LR(i) = 2-1/(1+exp(-dot(B_l,[1 data(i,1:data_param)])));
%     jaw_right_LR(i) = 2-1/(1+exp(-dot(B_r,[1 data(i,1:data_param)])));
%     jaw_both_LR(i) = 2-1/(1+exp(-dot(B_b,[1 data(i,1:data_param)])));
% end
% 
% j_learning_data_l = [jaw_left_ANN' jaw_left_LR' jaw_left_SVM jaw_left_KNN jaw_left_LDA];
% j_learning_data_r = [jaw_right_ANN' jaw_right_LR' jaw_right_SVM jaw_right_KNN jaw_right_LDA];
% j_learning_data_b = [jaw_both_ANN' jaw_both_LR' jaw_both_SVM jaw_both_KNN jaw_both_LDA];
% 
% if (OUTER_LOOP == 1)
%     j_B_l_ensemble = mnrfit(j_learning_data_l,training_target_l);
%     j_B_r_ensemble = mnrfit(j_learning_data_r,training_target_r);
%     j_B_b_ensemble = mnrfit(j_learning_data_b,training_target_b);
% end
% 
% for i=1:LOOP_NUM
%     jaw_left_ensemble(i) = 2-1/(1+exp(-dot(j_B_l_ensemble,[1 j_learning_data_l(i,:)])));
%     jaw_right_ensemble(i) = 2-1/(1+exp(-dot(j_B_r_ensemble,[1 j_learning_data_r(i,:)])));
%     jaw_both_ensemble(i) = 2-1/(1+exp(-dot(j_B_b_ensemble,[1 j_learning_data_b(i,:)])));
% end
% 
% % convene a council of the learned machines
% j_council(1:3,1:LOOP_NUM) = 0;
% % 1 = left, 2 = right
% for i = 1:LOOP_NUM    
%         
%     if(jaw_both_SVM(i) == 2)
%         j_council(1,i) = j_council(1,i) +1;
%     end
%     
%     if(jaw_both_KNN(i) == 2)
%         j_council(1,i) = j_council(1,i) +1;
%     end
%     
%     if(jaw_both_LDA(i) == 2)
%         j_council(1,i) = j_council(1,i) +1;
%     end
%     
%     if(jaw_right_SVM(i) == 2)
%         j_council(2,i) = j_council(2,i) +1;
%     end
%     
%     if(jaw_right_KNN(i) == 2)
%         j_council(2,i) = j_council(2,i) +1;
%     end
%     
%     if(jaw_right_LDA(i) == 2)
%         j_council(2,i) = j_council(2,i) +1;
%     end
%     
%     if(jaw_left_SVM(i) == 2)
%         j_council(3,i) = j_council(3,i) +1;
%     end
%     
%     if(jaw_left_KNN(i) == 2)
%         j_council(3,i) = j_council(3,i) +1;
%     end
%     
%     if(jaw_left_LDA(i) == 2)
%         j_council(3,i) = j_council(3,i) +1;
%     end
%     
% end
% 
% % lessons in british royalty
% % the kings are the average output of the Logistic Regression when it is
% % supposed to be 2. The closer to 2 the better!
% % the queens are the average output of the Logistic Regression when it is
% % supposed to be 1. The closer to 1 the better!
% 
% princes = [jaw_left_LR',jaw_right_LR',jaw_both_LR'];
% 
% counts(1:3) = 0;
% dukes(1:3) = 0;
% barons(1:3) = 0;
% earls(1:3) = 0;
% kings(1:3) = 0;
% queens(1:3) = 0;
% for i = 1:3
%     for j = 1:LOOP_NUM
%         if(jaw_out(j) == i)
%             dukes(i) = dukes(i) + princes(j,4-i);
%             counts(i) = counts(i) +1;
%         else
%             barons(i) = barons(i) + princes(j,4-i);
%             earls(i) = earls(i) +1;
%         end
%     end
%     kings(i) = dukes(i) / counts(i);
%     queens(i) = barons(i) / earls(i);
% end  
% % ROC curve - Jaw Clench
% 
% 
% % take into account training and practice runs
% if (OUTER_LOOP == 1)
%     for q = 1:3
%         success(q) = max(kings(q) - 0.1, 1.1);
%         %success(q) = 1.2;
%     end
% end
% jaw_success_ANN(1) = 1.5;
% jaw_success_ANN(2) = 1.4;
% jaw_success_ANN(3) = 1.5;
% jaw_target = [jaw_both_ANN', jaw_right_ANN', jaw_left_ANN']';
% 
% jaw_guess = zeros(1,LOOP_NUM);   
% num_params = 3;
% 
% for q = 1:num_params
% pos_count(q) = 0;
% neg_count(q) = 0;
% true_pos(q) = 0;
% true_neg(q) = 0;
%     for i = 1:LOOP_NUM
%         if(jaw_target(q,i) > jaw_success_ANN(q))
%                 jaw_guess(i) = q;            
%         end
% 
%         if(jaw_out(i) == q)
%             pos_count(q) = pos_count(q) +1;
%             if(jaw_target(q,i) > jaw_success_ANN(q))
%                 true_pos(q) = true_pos(q) + 1;
%             end
%         else 
%             neg_count(q) = neg_count(q) +1;
%             if(jaw_target(q,i) < jaw_success_ANN(q))
%                 true_neg(q) = true_neg(q)+ 1;
%             end
%         end
%     end
% end
% 
% jaw_guess_ensemble = zeros(1,LOOP_NUM);
% % Ensemble Learning
% jaw_target_ensemble = [jaw_both_ensemble' jaw_right_ensemble' jaw_left_ensemble'];
% 
% 
% for q = 1:num_params
% pos_count_LR(q) = 0;
% neg_count_LR(q) = 0;
% true_pos_LR(q) = 0;
% true_neg_LR(q) = 0;
%     for i = 1:LOOP_NUM
%         if(jaw_target_ensemble(i,q) > 1.2 || j_council(q,i) >= 2)
%                 if(jaw_target_ensemble(i,q) == max(jaw_target_ensemble(i,:)))
%                     jaw_guess_ensemble(i) = q; 
%                 end
%         end
%             
%         if(jaw_out(i) == q)
%             pos_count_LR(q) = pos_count_LR(q) +1;
%             if(jaw_target_ensemble(i,q) > 1.2 || j_council(q,i) >= 2)
%                 true_pos_LR(q) = true_pos_LR(q) +1;
%             end
%         else
%             neg_count_LR(q) = neg_count_LR(q) +1;
%             if(jaw_target_ensemble(i,q) <= 1.2 && j_council(q,i) < 2)
%                 true_neg_LR(q) = true_neg_LR(q)+ 1;
%             end
%         end
%     end
% end
% 
% THIS_IS_MY_FINAL_FORM = [jaw_out',jaw_guess_ensemble',jaw_both_ensemble',jaw_right_ensemble' ,jaw_left_ensemble' j_council'  ]; 
% jaw_data = [data,jaw_left_LR',jaw_right_LR',jaw_both_LR', jaw_out', jaw_guess',jaw_left_ANN',jaw_right_ANN',jaw_both_ANN'];
% 
% for q = 1:3
%     jaw_sens(q) = true_pos(q) / pos_count(q);
%     jaw_spec(q) = true_neg(q) / neg_count(q);
%     
%     jaw_sens_LR(q) = true_pos_LR(q) / pos_count_LR(q);
%     jaw_spec_LR(q) = true_neg_LR(q) / neg_count_LR(q);
% end
% 
% ROC = [jaw_sens_LR, jaw_spec_LR];
% 
% 
% if(OUTER_LOOP == 2)
%     savefile = 'jaw_ANN.mat';
%     save(savefile, 'j_net_l', 'j_net_r', 'j_net_b');
% 
% %     figure;
% %     hold on;
% %     plot(0:0.05:1,0:0.05:1,'r--');
% %     plot(1-jaw_spec(1),jaw_sens(1),'bd');
% %     plot(1-jaw_spec(2),jaw_sens(2),'gd');
% %     plot(1-jaw_spec(3),jaw_sens(3),'rd');
% %     legend('Random Guess','Both jaws','Right jaw','Left jaw');
% %     xlabel('1-specificity');
% %     ylabel('sensitivity');
% %     hold off;
%     
% 
% %     figure(1);
% %     hold on;
% %     plot(0:0.05:1,0:0.05:1,'r--');
% %     plot(1-jaw_spec_LR(1),jaw_sens_LR(1),'bd');
% %     plot(1-jaw_spec_LR(2),jaw_sens_LR(2),'gd');
% %     plot(1-jaw_spec_LR(3),jaw_sens_LR(3),'rd');
% %     legend('Random Guess','Both jaws','Right jaw','Left jaw');
% %     xlabel('1-specificity');
% %     ylabel('sensitivity');
% %     hold off;
% end
%% post run looking at things + training + ROC Curve- Mu Suppression
% % Left Hand, Right Hand, Left Foot, Right Foot
% 
% mu_data = [mu_pow' mu_corr' mu_var_ratio' mu_var'];
% 
% mu_data_size = size(mu_data);
% mu_data_param = mu_data_size(2);
% mu_param_num = 4;
% 
% if (OUTER_LOOP == 1)
%     mu_ANN_lh = feedforwardnet(5);
% %    mu_ANN_lh.trainParam.showWindow = 0;
%     mu_ANN_lh = train(mu_ANN_lh,mu_data(:,1:mu_data_param)',mu_target(:,1)');    
%     mu_SVM_lh = svmtrain(mu_data(:,1:mu_data_param)',mu_target(:,1)','autoscale','true','kernel_function','rbf');
%     mu_KNN_lh = ClassificationKNN.fit(mu_data(:,1:mu_data_param),mu_target(:,1)','NumNeighbors',20);
%     mu_LDA_lh = ClassificationDiscriminant.fit(mu_data(:,1:mu_data_param),mu_target(:,1)');
%     
%     mu_ANN_rh = feedforwardnet(5);
% %    mu_ANN_rh.trainParam.showWindow = 0;
%     mu_ANN_rh = train(mu_ANN_rh,mu_data(:,1:mu_data_param)',mu_target(:,2)');    
%     mu_SVM_rh = svmtrain(mu_data(:,1:mu_data_param)',mu_target(:,2)','autoscale','true','kernel_function','rbf');
%     mu_KNN_rh = ClassificationKNN.fit(mu_data(:,1:mu_data_param),mu_target(:,2)','NumNeighbors',20);
%     mu_LDA_rh = ClassificationDiscriminant.fit(mu_data(:,1:mu_data_param),mu_target(:,2)'); 
%     
%     
%     
%     
%     for i = 1:mu_param_num
%         mu_B(i,:) = mnrfit(mu_data(:,1:mu_data_param),mu_target(:,i));
%     end
% end
% 
% mu_lh_ANN_out = sim(mu_ANN_lh,mu_data(:,1:mu_data_param)');
% mu_lh_SVM_out = svmclassify(mu_SVM_lh,mu_data(:,1:mu_data_param));
% mu_lh_KNN_out = predict(mu_KNN_lh,mu_data(:,1:mu_data_param));
% mu_lh_LDA_out = predict(mu_LDA_lh,mu_data(:,1:mu_data_param));
% 
% mu_rh_ANN_out = sim(mu_ANN_rh,mu_data(:,1:mu_data_param)');
% mu_rh_SVM_out = svmclassify(mu_SVM_rh,mu_data(:,1:mu_data_param));
% mu_rh_KNN_out = predict(mu_KNN_rh,mu_data(:,1:mu_data_param));
% mu_rh_LDA_out = predict(mu_LDA_rh,mu_data(:,1:mu_data_param));
% 
% for i=1:LOOP_NUM
%     for k = 1:mu_param_num
%         mu_LR(k,i)= 2-1/(1+exp(-dot(mu_B(k,:),[1 mu_data(i,1:mu_data_param)])));
%     end
% end
% 
% mu_ensemble_data_lh = [mu_lh_ANN_out' mu_LR(1,:)' mu_lh_SVM_out mu_lh_KNN_out mu_lh_LDA_out];
% mu_ensemble_data_rh = [mu_rh_ANN_out' mu_LR(2,:)' mu_rh_SVM_out mu_rh_KNN_out mu_rh_LDA_out];
% 
% if (OUTER_LOOP == 1)
%     mu_B_lh_ensemble = mnrfit(mu_ensemble_data_lh,mu_target(:,1));
%     mu_B_rh_ensemble  = mnrfit(mu_ensemble_data_rh,mu_target(:,2));
% end
% 
% for i=1:LOOP_NUM
%     mu_out_lh_ensemble(i) = 2-1/(1+exp(-dot(mu_B_lh_ensemble,[1 mu_ensemble_data_lh(i,:)])));
%     mu_out_rh_ensemble(i) = 2-1/(1+exp(-dot(mu_B_rh_ensemble,[1 mu_ensemble_data_rh(i,:)])));
% end
% 
% mu_target_ensemble = [mu_out_lh_ensemble' mu_out_rh_ensemble'];
% 
% THIS_IS_MY_FINAL_FORM = [mu_marker' mu_target_ensemble  mu_lh_ANN_out' mu_rh_ANN_out' mu_LR(1:2,:)']; 
% %ROC curve - Mu Desynch
% for q = 1:2
% pos_count(q) = 0;
% neg_count(q) = 0;
% true_pos(q) = 0;
% true_neg(q) = 0;
%     for i = 1:LOOP_NUM
%         if(mu_marker(i) == q)
%             pos_count(q) = pos_count(q) +1;
%             if(mu_target_ensemble(i,q) >= 1.2)
%                 true_pos(q) = true_pos(q) + 1;
%             end
%         else 
%             neg_count(q) = neg_count(q) +1;
%             if(mu_target_ensemble(i,q) < 1.2)
%                 true_neg(q) = true_neg(q)+ 1;
%             end
%         end
%     end
% end
% 
% for q = 1:2
%     sensitivity(q) = true_pos(q) / pos_count(q);
%     false_pos(q) = pos_count(q) - true_pos(q);
%     specificity(q) = true_neg(q) / neg_count(q);
%     false_neg(q) = neg_count(q) - true_neg(q);
% end
% 
% results = [ true_pos', false_pos', true_neg', false_neg'];
% ROC = [sensitivity', specificity'];
% 
% figure;
% plot(0:0.05:1,0:0.05:1,'r--');
% hold on;
% plot(1-specificity(:),sensitivity(:),'rd');
% xlabel('1-specificity');
% ylabel('sensitivity');
% 
% legend('Random Guess');
%% post run looking at things + training + ROC Curve - Winking
% 
% %data = [wink_sigma,wink_var,wink_power, wink_diff_var, wink_p_ratio,wink_peak];
% data = [wink_v_ratio,wink_p_ratio,wink_peak];
% [COEFF,SCORE,latent] = pca(data);
% data_size = size(data);
% data_param = data_size(2);
% % 
% % COEFF = COEFF';
% %  for i = 1:LOOP_NUM
% %          data(i,:) = (COEFF')*data(i,:)';
% %  end
% %  data_param = 2;
% % end           
% %data(:,1:data_param) = COEFF*data(:,1:data_param);
% % take into account training and practice runs
% if (OUTER_LOOP == 1)
%     w_B_l = mnrfit(data(:,1:data_param),wink_left);
% %     w_net_l = feedforwardnet(5);
% %     w_net_l.trainParam.showWindow = 0;
% %     w_net_l = train(w_net_l,data(:,1:data_param)',wink_left); 
%     w_SVM_l = svmtrain(data(:,1:data_param)',wink_left,'autoscale','true','kernel_function','rbf');
%     w_KNN_l = ClassificationKNN.fit(data(:,1:data_param),wink_left,'NumNeighbors',20);
%     w_LDA_l = ClassificationDiscriminant.fit(data(:,1:data_param),wink_left);
%     
%     w_B_r = mnrfit(data(:,1:data_param),wink_right);
% %     w_net_r = feedforwardnet(5);
% %     w_net_r.trainParam.showWindow = 0;
% %     w_net_r = train(w_net_r,data(:,1:data_param)',wink_right);    
%     w_SVM_r = svmtrain(data(:,1:data_param)',wink_right,'autoscale','true','kernel_function','rbf');
%     w_KNN_r = ClassificationKNN.fit(data(:,1:data_param),wink_right,'NumNeighbors',20);
%     w_LDA_r = ClassificationDiscriminant.fit(data(:,1:data_param),wink_right);
%     
%     load('wink_ANN_Feb09-1.mat');
%   
%     w_B = [w_B_l w_B_r];  
% else
%     w_B_l = w_B(:,1);
%     w_B_r = w_B(:,2);
% end
% 
% wink_left_ANN = sim(w_net_l,data(:,1:data_param)');
% wink_right_ANN = sim(w_net_r,data(:,1:data_param)');
% 
% wink_left_SVM = svmclassify(w_SVM_l,data(:,1:data_param));
% wink_right_SVM = svmclassify(w_SVM_r,data(:,1:data_param));
% 
% wink_left_KNN = predict(w_KNN_l,data(:,1:data_param));
% wink_right_KNN = predict(w_KNN_r,data(:,1:data_param));
% 
% wink_left_LDA = predict(w_LDA_l,data(:,1:data_param));
% wink_right_LDA = predict(w_LDA_r,data(:,1:data_param));
% 
% %wink_left_MOG = predict(w_MOG_l,data(:,1:data_param));
% 
% for i=1:LOOP_NUM
%     wink_left_LR(i) = 2-1/(1+exp(-dot(w_B_l,[1 data(i,1:data_param)])));
%     wink_right_LR(i) = 2-1/(1+exp(-dot(w_B_r,[1 data(i,1:data_param)])));
% end
% 
% w_learning_data_l = [wink_left_ANN' wink_left_LR' wink_left_SVM wink_left_KNN wink_left_LDA];
% w_learning_data_r = [wink_right_ANN' wink_right_LR' wink_right_SVM wink_right_KNN wink_right_LDA];
% 
% if (OUTER_LOOP == 1)
%     w_B_l_inception = mnrfit(w_learning_data_l,wink_left);
%     w_B_r_inception = mnrfit(w_learning_data_r,wink_right);
% end
% 
% for i=1:LOOP_NUM
%     wink_left_ensemble(i) = 2-1/(1+exp(-dot(w_B_l_inception,[1 w_learning_data_l(i,:)])));
%     wink_right_ensemble(i) = 2-1/(1+exp(-dot(w_B_l_inception,[1 w_learning_data_r(i,:)])));
% end
% 
% % convene a council of the learned machines
% w_council(1:2,1:LOOP_NUM) = 0;
% % 1 = left, 2 = right
% for i = 1:LOOP_NUM
%     if(wink_left_SVM(i) == 2)
%         w_council(1,i) = w_council(1,i) +1;
%     end
%     
%     if(wink_left_KNN(i) == 2)
%         w_council(1,i) = w_council(1,i) +1;
%     end
%     
%     if(wink_left_LDA(i) == 2)
%         w_council(1,i) = w_council(1,i) +1;
%     end
%     
%     if(wink_right_SVM(i) == 2)
%         w_council(2,i) = w_council(2,i) +1;
%     end
%     
%     if(wink_right_KNN(i) == 2)
%         w_council(2,i) = w_council(2,i) +1;
%     end
%     
%     if(wink_right_LDA(i) == 2)
%         w_council(2,i) = w_council(2,i) +1;
%     end
%     
% end
%             
%         
% 
% % ROC curve - Winking
% % lessons in british royalty
% % the kings are the average output of the Logistic Regression when it is
% % supposed to be 2. The closer to 2 the better!
% % the queens are the average output of the Logistic Regression when it is
% % supposed to be 1. The closer to 1 the better!
% 
% princes = [wink_left_LR',wink_right_LR'];
% 
% num_params = 2;
% counts(1:num_params) = 0;
% dukes(1:num_params) = 0;
% barons(1:num_params) = 0;
% earls(1:num_params) = 0;
% kings(1:num_params) = 0;
% queens(1:num_params) = 0;
% for i = 1:num_params
%     for j = 1:counter
%         if(wink_out(j) == i)
%             dukes(i) = dukes(i) + princes(j,i);
%             counts(i) = counts(i) +1;
%         else
%             barons(i) = barons(i) + princes(j,i);
%             earls(i) = earls(i) +1;
%         end
%     end
%     kings(i) = dukes(i) / counts(i);
%     queens(i) = barons(i) / earls(i);
% end  
% 
% kings = abs(kings);
% queens = abs(queens);
% 
% % take into account training and practice runs
% if (OUTER_LOOP == 1)
%     for q = 1:num_params
%         %% Accurate Thresholds
% %         w_suc_ANN(q) = 1.1;
% %         thresh = 2.3;
%         
%         %% Normal Thresholds
%         w_suc_ANN(q) = 1.4;
%         thresh = 2.3;
%     end
% end
% 
% 
% %LR
% wink_target_LR = [wink_left_LR',wink_right_LR']';
% 
% %ANN
% wink_target_ANN = [wink_left_ANN' wink_right_ANN']';
% 
% % Meta Machine Learning
% wink_target_meta = [wink_left_ensemble' wink_right_ensemble'];
% 
% wink_guess = zeros(1,LOOP_NUM);
% 
% %make decisions about life
% for q = 1:num_params
% pos_count(q) = 0;
% neg_count(q) = 0;
% true_pos(q) = 0;
% true_neg(q) = 0;
%     for i = 1:LOOP_NUM
%         if(wink_target_ANN(q,i) > w_suc_ANN(q) || (wink_target_ANN(q,i) + wink_target_LR(q,i)) > thresh)
%                 if((wink_target_ANN(q,i)+ wink_target_LR(q,i)) > (wink_target_ANN((3-q),i)+ wink_target_LR((3-q),i)))
%                     wink_guess(i) = q;   
%                 end
%         end
%             
%         if(wink_out(i) == q)
%             pos_count(q) = pos_count(q) +1;
%             if(wink_guess(i) == q)
%                 true_pos(q) = true_pos(q) + 1;             
%             end
%         else 
%             neg_count(q) = neg_count(q) +1;
%             if(wink_guess(i) ~= q )
%                 true_neg(q) = true_neg(q)+ 1;
%             end
%         end
%     end
% end
% 
% %%%%make decisions about life
% wink_guess_ensemble = zeros(1,LOOP_NUM);
% 
% for q = 1:num_params
% pos_count_LR(q) = 0;
% neg_count_LR(q) = 0;
% true_pos_LR(q) = 0;
% true_neg_LR(q) = 0;
%     for i = 1:LOOP_NUM
%         if(wink_target_meta(i,q) > 1.2 || w_council(q,i) >= 1)
%                 wink_guess_ensemble(i) = q;
%         end
%             
%         if(wink_out(i) == q)
%             pos_count_LR(q) = pos_count_LR(q) +1;
%             if(wink_target_meta(i,q) > 1.2 || w_council(q,i) >= 1)
%                 true_pos_LR(q) = true_pos_LR(q) +1;
%             end
%         else
%             neg_count_LR(q) = neg_count_LR(q) +1;
%             if(wink_target_meta(i,q) <= 1.2 && w_council(q,i) < 1)
%                 true_neg_LR(q) = true_neg_LR(q)+ 1;
%             end
%         end
%     end
% end
% 
% for q = 1:num_params
%     wink_sens(q) = true_pos(q) / pos_count(q);
%     wink_spec(q) = true_neg(q) / neg_count(q);
%     
%     wink_sens_LR(q) = true_pos_LR(q) / pos_count_LR(q);
%     wink_spec_LR(q) = true_neg_LR(q) / neg_count_LR(q);
% end
% 
% wink_ROC = [wink_sens_LR wink_spec_LR];
% 
% 
% 
% wink_data = [data princes wink_out' wink_guess' wink_left_ANN' wink_right_ANN' wink_left_SVM  wink_right_SVM ];
% 
%     if(OUTER_LOOP == 2)
% %         figure;
% %         hold on;
% %         plot(0:0.05:1,0:0.05:1,'r--');
% %         plot(1-wink_spec_LR(1),wink_sens_LR(1),'bd');
% %         plot(1-wink_spec_LR(2),wink_sens_LR(2),'rd');
% %         legend('Random Guess','Left Wink','Right Wink');
% %         xlabel('1-specificity');
% %         ylabel('sensitivity');
% %         hold off;
%         
% %         
%            % savefile = 'wink_ANN.mat';
%            % save(savefile, 'w_net_l', 'w_net_r');
%     end
%     
%     
%% analyzing both wink and jaw
% THIS_IS_MY_FINAL_FORM = [wink_out',jaw_out',wink_guess_ensemble',jaw_guess_ensemble', w_council',j_council' ];
% 
%     if(OUTER_LOOP == 2)
%         
%         figure;
%         hold on;
%         plot(0:0.05:1,0:0.05:1,'r--');
%         plot(1-jaw_spec_LR(1),jaw_sens_LR(1),'bd');
%         plot(1-jaw_spec_LR(2),jaw_sens_LR(2),'gd');
%         plot(1-jaw_spec_LR(3),jaw_sens_LR(3),'rd');
%         plot(1-wink_spec_LR(1),wink_sens_LR(1),'cd');
%         plot(1-wink_spec_LR(2),wink_sens_LR(2),'kd');
%         legend('Random Guess','Both jaws','Right jaw','Left jaw','Left Wink','Right Wink');
%         xlabel('1-specificity');
%         ylabel('sensitivity');
%         hold off;
%         
% %         load('data_5feature.mat');
% %         
% %         A_size = size(A);
% %         A(A_size(1)+1,:) = [1-jaw_spec_LR 1-wink_spec_LR jaw_sens_LR wink_sens_LR];
% %         
% %         savefile = 'data_5feature.mat';
% %         save(savefile,'A');
%         
%     end
%% End of OUTER LOOP
%stuff
end
